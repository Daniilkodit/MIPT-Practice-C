#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <math.h>

/*
Потрясающая формула n2 + n + 41, открытая Эйлером,
генерирует для 0 <= n <= 39 положительные простые числа и только их
Если не ограничиваться положительными коэффициентами, то n2 - n + 41,
тривиально даёт на одно положительное простое больше (она начинается с 41, 41, и дальше полностью повторяет исходную последовательность)
Ещё более потрясающая формула 36n2 − 810n + 2753 генерирует одно за другим 45 простых
Ваша задача найти длину самой длинной последовательности положительных простых чисел,
которую можно сгенерировать с помощью формулы n2 + an + b, в предположеннии, что |a| < N и |b| < N
Обратите внимание: эти числа не обязаны быть последовательно возрастающими или убывающими.
Слово последовательность здесь употребляется в том смысле, что, начиная с n = 0, и до некоторого числа,
каждое очередное число оказывается простым. Например 3, 17, 17, 31, 5 это последовательность из пяти простых
Посылка должна состоять из программы,
считывающей со стандартного ввода число N и выводящей на стандартный вывод три числа:
a, b и длину наибольшей последовательности
*/
struct sieve_t {
    int n;
    char *s;
};
void fill(struct sieve_t *sv )
{
    int i,j;
    sv->s[1]=1;
    sv->s[0]=1;
    for(i = 2 ;i*i<sv->n;i++)
    {
        if(sv->s[i]==0)
        {
            for(j = i*i;j<sv->n;j+=i) sv->s[j]=1;
        }
    }
}
int Abs(int b){return b>0 ? b:-b;}
int is_prime(int num,struct sieve_t *sv)
{
    int i;
    num = Abs(num);
    if(num<sv->n) return sv->s[num]==0 ? 1:0;
    if((num % 2)==0) return 0;
    for(i = 3; i*i<=num;i+=2)
    {
        if((num%i)==0) return 0;
    }
    return 1;
}
int main(void)
{
    int N ,a,b,i;
    int amax=0,bmax=0,count = 0,cnt=0;
    struct sieve_t  resh;
    
    if(scanf("%d",&N)!=1) abort();
   
    resh.n = N;
    resh.s = calloc(N,sizeof(char));
    fill(&resh);
    a = ((N-1)%2)==0 ? (-N+2):(-N+1);
    for(a;a<N;a+=2)
    {
        for(b=((N-1)%2)==0 ? (-N+2):(-N+1);b<N;b+=2)
        {
            cnt = is_prime(b,&resh) + is_prime((a+b+1),&resh);
            if(cnt==2)
            {
                for(i =2;is_prime((i*i+i*a+b),&resh);i++) cnt++;
            }
            if(count<cnt) {count = cnt; amax = a; bmax =b;}
        }
        
    }
    printf("%d %d %d\n",amax,bmax,count);
    return 0;
}